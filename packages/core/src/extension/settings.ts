/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * This module handles extension settings management.
 * Settings are stored in .env files within extension directories.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import type { ExtensionSetting } from './extensionSettings.js';

/**
 * Parse .env file content into key-value pairs.
 * Simple parser that handles:
 * - KEY=VALUE format
 * - Comments starting with #
 * - Empty lines
 */
export function parseEnvFile(content: string): Record<string, string> {
  const result: Record<string, string> = {};
  const lines = content.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    // Parse KEY=VALUE
    const equalIndex = trimmed.indexOf('=');
    if (equalIndex === -1) {
      continue; // Invalid line, skip
    }

    const key = trimmed.substring(0, equalIndex).trim();
    const value = trimmed.substring(equalIndex + 1).trim();

    // Remove quotes if present
    let cleanValue = value;
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      cleanValue = value.substring(1, value.length - 1);
    }

    result[key] = cleanValue;
  }

  return result;
}

/**
 * Generate .env file content from key-value pairs.
 */
export function generateEnvFile(settings: Record<string, string>): string {
  const lines: string[] = [];

  lines.push('# Extension Settings');
  lines.push('# Generated by Qwen Code');
  lines.push('');

  for (const [key, value] of Object.entries(settings)) {
    // Quote values that contain spaces
    const quotedValue = value.includes(' ') ? `"${value}"` : value;
    lines.push(`${key}=${quotedValue}`);
  }

  return lines.join('\n') + '\n';
}

/**
 * Load settings from extension .env file.
 */
export async function loadExtensionSettings(
  extensionPath: string,
): Promise<Record<string, string>> {
  const envPath = path.join(extensionPath, '.env');

  try {
    const content = await fs.promises.readFile(envPath, 'utf-8');
    return parseEnvFile(content);
  } catch (error) {
    // If .env file doesn't exist, return empty object
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return {};
    }
    throw error;
  }
}

/**
 * Save settings to extension .env file.
 */
export async function saveExtensionSettings(
  extensionPath: string,
  settings: Record<string, string>,
): Promise<void> {
  const envPath = path.join(extensionPath, '.env');
  const content = generateEnvFile(settings);
  await fs.promises.writeFile(envPath, content, 'utf-8');
}

/**
 * Validate settings against configuration.
 * Returns array of validation errors (empty if valid).
 *
 * Note: This validates that environment variables are properly set.
 * In Gemini Extension format, all settings are treated as strings.
 */
export function validateSettings(
  settings: Record<string, string>,
  settingsConfig: ExtensionSetting[],
): string[] {
  const errors: string[] = [];

  for (const config of settingsConfig) {
    const value = settings[config.envVar];

    // Basic validation - check if value exists and is not empty
    // Note: All settings are optional in Gemini Extension format
    if (value !== undefined && typeof value !== 'string') {
      errors.push(
        `Setting "${config.name}" (${config.envVar}) must be a string`,
      );
    }
  }

  return errors;
}

/**
 * Merge extension settings into process environment.
 * This allows MCP servers and other extension components to access settings.
 */
export function applySettingsToEnv(settings: Record<string, string>): void {
  for (const [key, value] of Object.entries(settings)) {
    // Only set if not already defined in process.env
    if (process.env[key] === undefined) {
      process.env[key] = value;
    }
  }
}
